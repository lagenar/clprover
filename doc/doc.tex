\documentclass[a4paper,12pt]{article}
\usepackage[spanish]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage{listings} %Para poner código fuente
\title{Trabajo final de análisis y diseño de algoritmos I}
\author{Lucas Moauro}
\date{}
\begin{document}
\maketitle
\newpage
\tableofcontents
\section{Introducción}
% * Motivación para el tp.
% * Resúmen de cambios realizados, aclarar que fue reescrito.
% * Sobre Qt y la SDL(aclarar sobre la complejidad temporal de las estructuras).
% * Resúmen de el contenido de cada sección.
En este informe se presentan las modificaciones al programa Clausula que fueron realizadas como trabajo final
para la cátedra \emph{Análisis y diseño de algoritmos I}.

Clausula \cite{Clausula} es un deductor de lógica de primer orden; a partir de una lista de cláusulas es capaz
de determinar su satisfacibilidad. Además, provee otras funciones útiles para el estudio de lógica como la
unificación de literales y la simplificación de un conjunto de cláusulas utilizando diferentes criterios. Estas funcionalidades
son accesibles a través de una interfaz gráfica intuitiva. Este programa es utilizado por los alumnos de la cátedra \emph{Ciencias de la
computación II} dictada en el segundo año de la carrera.

La motivación del trabajo fue agregar optimizaciones y funcionalidades al programa,
a saber:
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\item La refactorización de las clases básicas(Término, Literal, Cláusula, etc). Se agregaron relaciones
de herencia y se cambiaron de lugar métodos.
\item Se cambió la gramática de las cláusulas permitiendo identificadores de más de un caracter. Se creó una clase
que provee la adición y eliminación de clausulas y el manejo de errores sintácticos y semánticos.
\item Se creó una clase abstracta que sirve de base para las diferentes estrategias de resolución.
\item Los procedimientos de resolución corren en un hilo de ejecución diferente, lo que permite al usuario detener la resolución sin tener que
salir del programa.
\item Se agregó una regla de inferencia(factorización) que es necesaria para la completitud de los métodos de resolución.
\item Se implementó una simplificación conocida como \emph{simplificación por literales eliminables}.
\item Se implementó una simplificación por subsunción de cláusulas.
\item Se implementó una simplificación de la traza de resolución que elimina las inferencias que no fueron
usadas para derivar la cláusula vacía y se agregó un indexamiento de cláusulas. Esto hace que las pruebas sean
más cortas y legibles.
\item Se integró Clausula con un programa para transformar fórmulas a la forma clausular, lo que permite al usuario
determinar la satisfacibilidad de fórmulas arbitrarias.
\item Se separó completamente la interfaz gráfica de los algoritmos y clases fundamentales, de esta forma
pueden usarse sin mayores dependencias en otros proyectos.
\end{itemize}
En este proyecto se usaron extensivamente los contenedores provistos por la STL(listas, mapas, conjuntos, etc). Además
de la especificación formal de cada contenedor, la STL especifica la complejidad temporal asintótica de los métodos de
inserción, eliminación, etc.\cite{sgi}

\section{Estructuras básicas de lógica de primer orden}
%En esta sección tengo que explicar desde el punto de vista de lógica de primer orden
%a los términos(variables y funciones), literales, y cláusulas. Después hay que describir
%las clases utilizadas para representarlos, sin hacer incapié en como están implementados
%los algoritmos, sólo la interfaz externa. También Sustitución y Argumentos.
En esta sección se describen las estructuras básicas de lógica de primer orden que sirven de base para los métodos de resolución.
Primero se introducen a partir de su definición en lógica y luego se plantea la correspondencia a los tipos de datos abstractos
y a su implementación a través de las clases de C++ describiendo los métodos más importantes de cada clase. 
Por último, se dan a conocer las estructuras utilizadas para la representación interna de las clases.

Los principales cambios con respecto a las estructuras de \emph{Clausula} son las relaciones de herencia
en las clases que representan términos, la representación interna y la inclusión de métodos que en Clausula
se encontraban en una clase monolítica llamada \emph{CAlgoritmos}.
\subsection{Términos: Variables y Funciones} %también la clase argumentos
En lógica de primer orden, el conjunto de términos es definido inductivamente \cite{ApuntesLogica}:
\begin{enumerate}
\item Una \emph{variable} es un término.
\item Si $t_1,t_2,...,t_n$ son términos y $f$ es un símbolo de \emph{función}, entonces $f(t_1,t_2,...,t_n)$
  es un término.\footnote{Las constantes son funciones de aridad 0.}
\end{enumerate}
Las variables se caracterizan por tener un identificador y las funciones un identificador y argumentos. La existencia de
dos tipos de términos, sugiere la utilización de un  TDA \emph{Termino} del cual se derivan los TDAs \emph{Variable} y 
\emph{Funcion}.
\begin{center}
\leavevmode
\includegraphics[height=2cm]{imagenes/classTermino}
\end{center}

En la clase abstracta Termino se declaran métodos a ser implementados en sus clases derivadas
\footnote{La documentación detallada de cada método se encuentra en el manual de referencia de clases.}.
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\item const std::string \& getId () const
\item t getTipo () const
\item virtual const std::string getString () const =0
\item virtual bool operator== (const Termino \&otro) const =0
\item virtual bool contieneVariable (const std::string \&id) const =0
\item virtual Termino $\ast$ aplicarSustitucion (const Sustitucion \&s) const =0
\item virtual bool unificar (Sustitucion \&s, const Termino \&otro) const =0
\item virtual bool unificarSubsuncion (Sustitucion \&s, const Termino \&otro) const =0
\item virtual void renombrarVariables (std::map< std::string, std::string > \&renombre, int \&comienzo)=0
\end{itemize}
La clase Funcion, además de implementar los métodos virtuales de la clase Termino,
provee métodos específicos a las funciones de lógica de primer orden, como el acceso a la aridad
de la función y la adición de argumentos.

Existe otra estructura lógica que posee términos como argumentos, el Literal. Por este motivo, es conveniente
encapsular el concepto de argumentos en una clase que provea funcionalidad para ambas clases. La clase \emph{Argumentos}
cumple este objetivo.
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\item Argumentos (const Argumentos \&Args)
\item int aridad () const
\item const std::string getString () const
\item const\_iterator begin () const
\item const\_iterator end () const
\item bool operator== (const Argumentos \&otro) const
\item bool contieneVariable (const std::string \&id) const
\item bool unificar (Sustitucion \&s, const Argumentos \&otro) const
\item bool unificarSubsuncion (Sustitucion \&s, const Argumentos \&otro) const
\item void agregarArgumento (const Termino \&t)
\item void aplicarSustitucion (const Sustitucion \&s)
\item void renombrarVariables (std::map< std::string, std::string > \&renombre, int \&comienzo)
\end{itemize}
Para la representación interna de los argumentos en la clase Argumentos se optó por
usar una lista de punteros a objetos de la clase Termino. De esta forma, la inserción de términos
tiene complejidad constante y la utilización de punteros permite que los argumentos sean objetos polimórficos.

Para representar los identificadores de las variables y funciones se usa la clase \emph{string} de la STL.
\subsection{Sustitución}
Una sustitución es una asignación de variables a términos. Estas son utilizadas en la implementación de los
algoritmos de unificación y en el renombre de variables para estandarizar estructuras lógicas.
El TDA debe proveer funciones para la consulta, asignación y composición de sustituciones.
La clase \emph{Sustitucion} implementa el TDA.
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\item const Termino $\ast$ getSustitucion (const std::string \&id) const
\item void agregarSustitucion (const std::string \&id, const Termino \&t)
\item void componer (const Sustitucion \&s)
\end{itemize}
La estructura interna de la clase esta compuesta por un mapa de la STL en el cual los
índices son identificadores de variables y los valores son punteros a términos. El mapa
provee acceso aleatorio a las sustituciones garantizando una complejidad temporal de 
$O(\log n)$, siendo $n$ la cantidad de sustituciones en el mapa.
\subsection{Literal}
En lógica de primer orden un literal es una fórmula atómica o la negación de una.
Esta caracterizado por tener un signo, identificador y argumentos. Los argumentos
de un literal son términos.
La clase \emph{Literal} provee métodos para el acceso y modificación de un literal. También
implementa métodos que son usados en el cálculo de resolventes, por ejemplo un método que determina
si dos literales son complementarios.
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\item Literal (const std::string \&id, bool signo)
\item Literal (const std::string \&id, const Argumentos \&args, bool signo)
\item bool getSigno () const
\item const std::string \& getId () const
\item const std::string getString () const
\item int aridad () const
\item bool operator== (const Literal \&otro) const
\item bool operator!= (const Literal \&otro) const
\item const\_iterator begin () const
\item const\_iterator end () const
\item bool unificar (const Literal \&otro, Sustitucion \&s) const
\item bool unificable (const Literal \&otro) const
\item bool unificarComplementario (const Literal \&otro, Sustitucion \&s) const
\item bool unificarSubsuncion (const Literal \&otro, Sustitucion \&s) const
\item void aplicarSustitucion (const Sustitucion \&s)
\item void agregarArgumento (const Termino \&t)
\item void setSigno (bool s)
\item void renombrarVariables (std::map< std::string, std::string > \&renombre, int \&comienzo)
\item void renombrarVariables (int \&comienzo)
\end{itemize}
Como se ha mencionado anteriormente, la estructura interna de los argumentos de la clase
\emph{Literal} está representada por un objeto de la clase \emph{Argumentos}.
\subsection{Cláusula}
Una cláusula es una disyunción de literales. Es la estructura lógica sobre la cual se basan
las estrategias de resolución. La clase \emph{Clausula} implementa esta estructura. Provee operaciones
para la consulta e inserción de literales y para aplicar las dos reglas de inferencia fundamentales en
el cálculo de resolución: el cálculo de resolventes entre dos cláusulas y la factorización de una cláusula.
Un detalle importante es que la clase permite asignar un entero como identificador a una cláusula creada. Los
identificadores son usados para indexar las cláusulas y aplicar simplificaciones a la traza de resolución.
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\item Clausula (int id\_resolucion=0)
\item int cantLiterales () const
\item bool esUnitaria () const
\item bool esDeHorn (t\_horn \&t) const
\item bool esDeHorn () const
\item bool esVacia () const
\item bool esTautologica () const
\item const std::string getString () const
\item int getIdResolucion () const
\item const\_iterator begin () const
\item const\_iterator end () const
\item bool contieneComplementario (const Literal \&lit) const
\item bool contienePredicado (const std::string \&id\_pred) const
\item bool subsume (const Clausula \&otra) const
\item void resolventes (const Clausula \&claus, std::list< Clausula > \&res) const
\item bool resolventeUsandoPred (const Clausula \&claus, const std::string \&id\_pred, Clausula \&res) const
\item void factores (std::list< Clausula > \&fact) const
\item bool equivalente (const Clausula \&C) const
\item Clausula renombrarVariables (int \&comienzo) const
\item std::map< std::string, int > aparicionesPredicados () const
\item void agregarLiteral (const Literal \&lit)
\item void setIdResolucion (int id)
\end{itemize}
Para la representación interna de los literales se utiliza un set de la STL. La disyunción puede interpretarse como
un conjunto de literales teniendo en cuenta la propiedad de idempotencia, esta indica que una cláusula que contiene
$n$ iguales es equivalente a una cláusula obtenida de eliminar $n-1$ de los $n$ literales iguales. Para poder usar
un set es necesario definir un orden parcial para los literales, este orden está definido en la clase \emph{LitComp}.
El hecho de que los literales se encuentren ordenados permite hacer que varios métodos de la clase sean más eficientes,
ya que al conocer esta propiedad no deben iterar sobre todo el conjunto de literales.
\section{Análisis sintáctico de cláusulas} %gramática y parser.
\bibliographystyle{plain}
\bibliography{doc}
\end{document}
