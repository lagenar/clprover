\documentclass[a4paper,12pt]{article}
\usepackage[spanish]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage{listings} %Para poner código fuente
%\usepackage{caption}
\title{Trabajo final de análisis y diseño de algoritmos I}
\author{Lucas Moauro}
\date{}
\begin{document}
\maketitle
\newpage
\tableofcontents
\section{Introducción}
% * Motivación para el tp.
% * Resúmen de cambios realizados, aclarar que fue reescrito.
% * Sobre Qt y la SDL(aclarar sobre la complejidad temporal de las estructuras).
% * Resúmen de el contenido de cada sección.
En este informe se presentan las modificaciones al programa Clausula que fueron realizadas como trabajo final
para la cátedra \emph{Análisis y diseño de algoritmos I}.

Clausula \cite{Clausula} es un deductor de lógica de primer orden; a partir de una lista de cláusulas es capaz
de determinar su satisfacibilidad. Además, provee otras funciones útiles para el estudio de lógica como la
unificación de literales y la simplificación de un conjunto de cláusulas utilizando diferentes criterios. Estas funcionalidades
son accesibles a través de una interfaz gráfica intuitiva. Este programa es utilizado por los alumnos de la cátedra \emph{Ciencias de la
computación II} dictada en el segundo año de la carrera.

La motivación del trabajo fue agregar optimizaciones y funcionalidades al programa,
a saber:
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\item La refactorización de las clases básicas(Término, Literal, Cláusula, etc). Se agregaron relaciones
de herencia y se cambiaron de lugar métodos.
\item Se cambió la gramática de las cláusulas permitiendo identificadores de más de un caracter. Se creó una clase
que provee la adición y eliminación de clausulas y el manejo de errores sintácticos y semánticos.
\item Se creó una clase abstracta que sirve de base para las diferentes estrategias de resolución.
\item Los procedimientos de resolución corren en un hilo de ejecución diferente, lo que permite al usuario detener la resolución sin tener que
salir del programa.
\item Se agregó una regla de inferencia(factorización) que es necesaria para la completitud de los métodos de resolución.
\item Se implementó una simplificación conocida como \emph{simplificación por literales eliminables}.
\item Se implementó una simplificación por subsunción de cláusulas.
\item Se implementó una simplificación de la traza de resolución que elimina las inferencias que no fueron
usadas para derivar la cláusula vacía y se agregó un indexamiento de cláusulas. Esto hace que las pruebas sean
más cortas y legibles.
\item Se integró Clausula con un programa para transformar fórmulas a la forma clausular, lo que permite al usuario
determinar la satisfacibilidad de fórmulas arbitrarias.
\item Se separó completamente la interfaz gráfica de los algoritmos y clases fundamentales, de esta forma
pueden usarse sin mayores dependencias en otros proyectos.
\end{itemize}
En este proyecto se usaron extensivamente los contenedores provistos por la STL(listas, mapas, conjuntos, etc). Además
de la especificación formal de cada contenedor, la STL especifica la complejidad temporal asintótica de los métodos de
inserción, eliminación, etc.\cite{sgi}

\section{Estructuras básicas de lógica de primer orden}
%En esta sección tengo que explicar desde el punto de vista de lógica de primer orden
%a los términos(variables y funciones), literales, y cláusulas. Después hay que describir
%las clases utilizadas para representarlos, sin hacer incapié en como están implementados
%los algoritmos, sólo la interfaz externa. También Sustitución y Argumentos.
En esta sección se describen las estructuras básicas de lógica de primer orden que sirven de base para los métodos de resolución.
Primero se introducen a partir de su definición en lógica y luego se plantea la correspondencia a los tipos de datos abstractos
y a su implementación a través de las clases de C++ describiendo los métodos más importantes de cada clase. 
Por último, se dan a conocer las estructuras utilizadas para la representación interna de las clases.

Los principales cambios con respecto a las estructuras de \emph{Clausula} son las relaciones de herencia
en las clases que representan términos, la representación interna y la inclusión de métodos que en Clausula
se encontraban en una clase monolítica llamada \emph{CAlgoritmos}.
\subsection{Términos: Variables y Funciones} %también la clase argumentos
En lógica de primer orden, el conjunto de términos es definido inductivamente \cite{ApuntesLogica}:
\begin{enumerate}
\item Una \emph{variable} es un término.
\item Si $t_1,t_2,...,t_n$ son términos y $f$ es un símbolo de \emph{función}, entonces $f(t_1,t_2,...,t_n)$
  es un término.\footnote{Las constantes son funciones de aridad 0.}
\end{enumerate}
Las variables se caracterizan por tener un identificador y las funciones un identificador y argumentos. La existencia de
dos tipos de términos, sugiere la utilización de un  TDA \emph{Termino} del cual se derivan los TDAs \emph{Variable} y 
\emph{Funcion}.
\begin{center}
\leavevmode
\includegraphics[height=2cm]{imagenes/classTermino.eps}
\end{center}

En la clase abstracta Termino se declaran métodos a ser implementados en sus clases derivadas
\footnote{La documentación detallada de cada método se encuentra en el manual de referencia de clases.}.
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\item const std::string \& getId () const
\item t getTipo () const
\item virtual const std::string getString () const =0
\item virtual bool operator== (const Termino \&otro) const =0
\item virtual bool contieneVariable (const std::string \&id) const =0
\item virtual Termino $\ast$ aplicarSustitucion (const Sustitucion \&s) const =0
\item virtual bool unificar (Sustitucion \&s, const Termino \&otro) const =0
\item virtual bool unificarSubsuncion (Sustitucion \&s, const Termino \&otro) const =0
\item virtual void renombrarVariables (std::map< std::string, std::string > \&renombre, int \&comienzo)=0
\end{itemize}
La clase Funcion, además de implementar los métodos virtuales de la clase Termino,
provee métodos específicos a las funciones de lógica de primer orden, como el acceso a la aridad
de la función y la adición de argumentos.

Existe otra estructura lógica que posee términos como argumentos, el Literal. Por este motivo, es conveniente
encapsular el concepto de argumentos en una clase que provea funcionalidad para ambas clases. La clase \emph{Argumentos}
cumple este objetivo.
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\item Argumentos (const Argumentos \&Args)
\item int aridad () const
\item const std::string getString () const
\item const\_iterator begin () const
\item const\_iterator end () const
\item bool operator== (const Argumentos \&otro) const
\item bool contieneVariable (const std::string \&id) const
\item bool unificar (Sustitucion \&s, const Argumentos \&otro) const
\item bool unificarSubsuncion (Sustitucion \&s, const Argumentos \&otro) const
\item void agregarArgumento (const Termino \&t)
\item void aplicarSustitucion (const Sustitucion \&s)
\item void renombrarVariables (std::map< std::string, std::string > \&renombre, int \&comienzo)
\end{itemize}
Para la representación interna de los argumentos en la clase Argumentos se optó por
usar una lista de punteros a objetos de la clase Termino. De esta forma, la inserción de términos
tiene complejidad constante y la utilización de punteros permite que los argumentos sean objetos polimórficos.

Para representar los identificadores de las variables y funciones se usa la clase \emph{string} de la STL.
\subsection{Sustitución}
Una sustitución es una asignación de variables a términos. Estas son utilizadas en la implementación de los
algoritmos de unificación y en el renombre de variables para estandarizar estructuras lógicas.
El TDA debe proveer funciones para la consulta, asignación y composición de sustituciones.
La clase \emph{Sustitucion} implementa el TDA.
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\item const Termino $\ast$ getSustitucion (const std::string \&id) const
\item void agregarSustitucion (const std::string \&id, const Termino \&t)
\item void componer (const Sustitucion \&s)
\end{itemize}
La estructura interna de la clase esta compuesta por un mapa de la STL en el cual los
índices son identificadores de variables y los valores son punteros a términos. El mapa
provee acceso aleatorio a las sustituciones garantizando una complejidad temporal de 
$O(\log n)$, siendo $n$ la cantidad de sustituciones en el mapa.
\subsection{Literal}
En lógica de primer orden un literal es una fórmula atómica o la negación de una.
Esta caracterizado por tener un signo, identificador y argumentos. Los argumentos
de un literal son términos.
La clase \emph{Literal} provee métodos para el acceso y modificación de un literal. También
implementa métodos que son usados en el cálculo de resolventes, por ejemplo un método que determina
si dos literales son complementarios.
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\item Literal (const std::string \&id, bool signo)
\item Literal (const std::string \&id, const Argumentos \&args, bool signo)
\item bool getSigno () const
\item const std::string \& getId () const
\item const std::string getString () const
\item int aridad () const
\item bool operator== (const Literal \&otro) const
\item bool operator!= (const Literal \&otro) const
\item const\_iterator begin () const
\item const\_iterator end () const
\item bool unificar (const Literal \&otro, Sustitucion \&s) const
\item bool unificable (const Literal \&otro) const
\item bool unificarComplementario (const Literal \&otro, Sustitucion \&s) const
\item bool unificarSubsuncion (const Literal \&otro, Sustitucion \&s) const
\item void aplicarSustitucion (const Sustitucion \&s)
\item void agregarArgumento (const Termino \&t)
\item void setSigno (bool s)
\item void renombrarVariables (std::map< std::string, std::string > \&renombre, int \&comienzo)
\item void renombrarVariables (int \&comienzo)
\end{itemize}
Como se ha mencionado anteriormente, la estructura interna de los argumentos de la clase
\emph{Literal} está representada por un objeto de la clase \emph{Argumentos}.
\subsection{Cláusula}
Una cláusula es una disyunción de literales. Es la estructura lógica sobre la cual se basan
las estrategias de resolución. La clase \emph{Clausula} implementa esta estructura. Provee operaciones
para la consulta e inserción de literales y para aplicar las dos reglas de inferencia fundamentales en
el cálculo de resolución: el cálculo de resolventes entre dos cláusulas y la factorización de una cláusula.
Un detalle importante es que la clase permite asignar un entero como identificador a una cláusula creada. Los
identificadores son usados para indexar las cláusulas y aplicar simplificaciones a la traza de resolución.
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\item Clausula (int id\_resolucion=0)
\item int cantLiterales () const
\item bool esUnitaria () const
\item bool esDeHorn (t\_horn \&t) const
\item bool esDeHorn () const
\item bool esVacia () const
\item bool esTautologica () const
\item const std::string getString () const
\item int getIdResolucion () const
\item const\_iterator begin () const
\item const\_iterator end () const
\item bool contieneComplementario (const Literal \&lit) const
\item bool contienePredicado (const std::string \&id\_pred) const
\item bool subsume (const Clausula \&otra) const
\item void resolventes (const Clausula \&claus, std::list< Clausula > \&res) const
\item bool resolventeUsandoPred (const Clausula \&claus, const std::string \&id\_pred, Clausula \&res) const
\item void factores (std::list< Clausula > \&fact) const
\item bool equivalente (const Clausula \&C) const
\item Clausula renombrarVariables (int \&comienzo) const
\item std::map< std::string, int > aparicionesPredicados () const
\item void agregarLiteral (const Literal \&lit)
\item void setIdResolucion (int id)
\end{itemize}
Para la representación interna de los literales se utiliza un set de la STL. La disyunción puede interpretarse como
un conjunto de literales teniendo en cuenta la propiedad de idempotencia, esta indica que una cláusula que contiene
$n$ iguales es equivalente a una cláusula obtenida de eliminar $n-1$ de los $n$ literales iguales. Para poder usar
un set es necesario definir un orden parcial para los literales, este orden está definido en la clase \emph{LitComp}.
El hecho de que los literales se encuentren ordenados permite hacer que varios métodos de la clase sean más eficientes,
ya que al conocer esta propiedad no deben iterar sobre todo el conjunto de literales.
\section{Análisis sintáctico de cláusulas} %gramática y parser.
Para interpretar la entrada de cláusulas es necesario definir una sintaxis concreta para las estructuras
lógicas y de esta forma poder transformar una cadena ingresada a una clase con sus respectivos atributos.
La refactorización de la gramática se hizo por ciertas limitaciones en la gramática de Clausula. También
se creo una clase, \emph{Parser} que encapsula métodos para analizar un conjunto de cláusulas.
\subsection{Gramática}
La principal limitación en la gramática de Clausula es que los identificadores de variables, funciones y literales
están compuestos por un símbolo alfabético, lo que impide que el usuario pueda asignar nombres más significativos. Además,
en problemas no triviales, con una mayor cantidad de identificadores puede que no pueda representarse el problema
usando esa gramática. En la nueva gramática los identificadores pueden contener más de un caracter.

En Clausula es necesario definir que identificadores son símbolos de constantes porque el conjunto
de símbolos posibles para asignar a las variables es igual al de las constantes. Esto se resuelve haciendo
que el conjunto de identificadores para las constantes sea diferente al de las variables; los
identificadores de variables empiezan con una letra mayúscula y los identificadores de literales, funciones y constantes
empiezan con minúscula.

A continuación se define la nueva gramática en formato \emph{BNF}.
%gramática
\lstinputlisting[basicstyle=\small,caption=Gramática, frame=single]{gramatica.bnf}
En cuanto a la implementación, se cambió el uso de \emph{Bison} por el de la biblioteca \emph{Spirit}\cite{spirit}.
El principal motivo es que provee una mejor integración con el lenguaje C++ y la gramática puede usarse como una biblioteca
sin la necesidad de invocar a un programa externo para el análisis sintáctico\footnote{Esto también es posible con Bison pero es más complejo.}.
\subsection{Parser}
La gramática definida en \emph{Spirit} detecta los posibles errores sintácticos en la definición
de una cláusula pero no los errores semánticos. Existen dos posibles errores semánticos:
\begin{enumerate}
\item Un identificador de función o predicado es usado con diferentes aridades. Por ejemplo, $a(X) \lor a(X,Y)$ no
es una cláusula bien definida.
\item Un identificador es usado para identificar a una función y a un predicado. Por ejemplo $a(a(X))$ no es válida.
\end{enumerate}
Estos errores semánticos pueden ser errores dentro de una misma cláusula o puede que sean producto de una
inconsistencia entre dos o más cláusulas. La clase \emph{Parser} es la encargada de analizar incrementalmente
un conjunto de cláusulas, verificando la validez del conjunto cada vez que se agrega o elimina una cláusula.
Esta clase es usada como modelo de datos en la interfaz gráfica que acepta cadenas ingresadas por el usuario.
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\item void parseClausula (int id, const std::string \&clausula, bool \&error, std::pair< t\_error, std::string >\&E)
\item void eliminarClausula (int id)
\item Clausula getClausula (int id) const
\item void getClausulas (std::list< Clausula > \&l) const
\item void getClausulas (ConjuntoClausulas<> \&claus) const
\end{itemize}
En la representación interna de las cláusulas se usa un mapa de enteros a cláusulas, los enteros
son identificadores provistos por el cliente de la clase para después poder consultar una cláusula
del conjunto o eliminarla. También se utilizan mapas de tipo y aridad para la verificación semántica
de las cláusulas.
\section{Factorización de cláusulas}
La regla de inferencia de factorización\cite{PracticalLogic} es necesaria para que los métodos de
resolución sean refutacionalmente completos. En Clausula esta regla no esta presente por lo que
para ciertos conjuntos de cláusulas insatisfacibles no consigue derivar la cláusula vacía.

A modo de ejemplo puede considerarse el siguiente conjunto de cláusulas:
\begin{enumerate}
\item $s(X,X)\lor s(b,X)$
\item $\lnot s(Y,Y)\lor \lnot s(b,Y)$
\end{enumerate}
Este conjunto puede probarse insatisfacible usando modelos de Herbrand pero no es posible
derivar la cláusula vacía usando sólo la regla de la resolvente como se muestra a continuación.
\begin{enumerate}
\item $s(X,X)\lor s(b,X)$
\item $\lnot s(Y,Y)\lor \lnot s(b,Y)$
\item $Res(1,2) \equiv s(b,X) \lor \lnot s(b,X) \equiv T$ usando la sustitución \{Y/X\} y los
literales $s(X,X)$ y $\lnot s(Y,Y)$ como complementarios.
\item $Res(1,2) \equiv s(X,X) \lor \lnot s(Y,Y) \equiv T$ usando la sustitución \{Y/X\} y los
literales $s(b,X)$ y $\lnot s(b,Y)$ como complementarios.
\end{enumerate}
La regla de factorización consiste en unificar dos literales en una cláusula y crear una nueva
cláusula aplicando la sustitución que unifica a esos dos literales. Utilizando esta regla puede
derivarse la cláusula vacía en el ejemplo anterior.
\begin{enumerate}
\item $s(X,X)\lor s(b,X)$
\item $\lnot s(Y,Y)\lor \lnot s(b,Y)$
\item $Factor(1) \equiv s(b,b)$ \{X/b\}
\item $Factor(2) \equiv \lnot s(b,b)$ \{Y/b\}
\item $Res(3,4) \equiv \bot$
\end{enumerate}
El algoritmo de factorización está implementado en la clase Clausula, en el método
Clausula::factores, este inserta los factores de la cláusula a una lista pasada
por referencia.
\lstinputlisting[caption=Factores, frame=single, numbers=left,language=C++,basicstyle=\tiny]{factores.cpp}
La complejidad del algoritmo es determinada por los ciclos anidados en las lineas 3, 6 y 10. Estos iteran
sobre los literales de la cláusula, por lo que la complejidad es de $O(n^3)$, siendo $n$ la cantidad de
literales de la cláusula.%FIX
\section{Estructuras de resolución}
En esta sección se presentan las clases usadas para la determinación de la satisfacibilidad
de cláusulas.
\subsection{ConjuntoClausulas}
La clase \emph{ConjuntoClausulas} representa un conjunto de cláusulas. Provee métodos
para la simplificación y la determinación de propiedades del conjunto.
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\item template<typename Iterator > ConjuntoClausulas (Iterator begin, Iterator end, bool numerar=false)
\item size\_type cantidadClausulas () const
\item bool esVacio () const
\item bool esDeHorn () const
\item bool esLogicaPrograma () const
\item void agregarClausula (const Clausula \&C)
\item bool simplificarPorTautologicas ()
\item bool simplificarPorEquivalentes ()
\item bool simplificarLiteralesPuros ()
\item bool contieneClausula (const Clausula \&c) const
\item void getClausulas (std::list< Clausula > \&l) const
\item std::set< std::string > predicadosEliminables () const
\item const\_iterator begin () const
\item const\_iterator end () const
\item iterator begin ()
\item iterator end ()
\item void eliminar (iterator c)
\end{itemize}
Para representar el conjunto de cláusulas, se usa un set de la STL.

En las estrategías de resolución es útil poder definir mas de un orden parcial para el ordenamiento de
las cláusulas. Por este motivo la clase \emph{ConjuntoClausulas} fue implementada con un template que
permite parametrizar el orden parcial a utilizar. El orden que se utiliza por defecto ordena las cláusulas
en por cantidad de literales en forma creciente.
\subsection{Inferencia}
\subsection{Resolucion}
\bibliographystyle{plain}
\bibliography{doc}
\end{document}
